<!DOCTYPE HTML>
<html lang="en"><!-- InstanceBegin template="/Templates/pageModule.dwt" codeOutsideHTMLIsLocked="false" -->
<head>

<meta charset="utf-8">
<!-- InstanceBeginEditable name="doctitle" -->
<title>My Library</title>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="head" -->
<!-- InstanceEndEditable -->

<link href="../../stylesheet.css"    rel="stylesheet" />
<link href="../../Graphics/Icon.ico" rel="shortcut icon" />

<!--[if lte IE 7]>
<style>
.content { margin-right: -1px; } /* this 1px negative margin can be placed on any of the columns in
                                                                        this layout with the same corrective effect. */
ul.nav a { zoom: 1; }                    /* the zoom property gives IE the hasLayout trigger it needs to correct
                                                                        extra whiltespace between the links */
</style>
<![endif]-->

<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

<script type="text/javascript">
function MM_jumpMenu(targ,selObj,restore){ //v3.0
  eval(targ+".location='"+selObj.options[selObj.selectedIndex].value+"'");
  if (restore) selObj.selectedIndex=0;
}
</script>
</head>

<body>

<div class="container">

  <header>
    <hgroup>
      <a href="../../index.htm" id="LogoLink"><img src="../../Graphics/swdeLogo200.jpg" alt="Logo" /></a>
      <div class="TitleBlock">
        <a href="../../index.htm">
            <h1>Software Design &amp; Engineering</h1>
            <h1>
                    <!-- InstanceBeginEditable name="PageTitle" -->
            Library
          <!-- InstanceEndEditable -->
          </h1>
        </a>
      </div>
      <div class="TitleBlock" id="DropDown">
        <ul>
          <li><a href="../../index.htm">Home</a></li>
          <li><a href="../index.htm">Modules</a>
            <ul id="ModulesDrop">
              <li><a href="../PersonalProjs/KeePass.htm">KeePass/LastPass</a></li>
              <li><a href="MyLibrary.htm">Library</a></li>
              <li><a href="../PersonalProjs/MvMp3.htm">Move Mp3 Tracks</a></li>
              <li><a href="../SJRACESProjs/PreOutpost.htm">PreOutpost</a></li>
              <li><a href="../PersonalProjs/PrntProgramAndWix.htm">Print Program (pp)</a></li>
              <li><a href="../SJRACESProjs/RWracesDB.htm">Read/Write RACES DB</a></li>
              <li><a href="../PersonalProjs/PrntProgramAndWix.htm#SetEnv">Set Environment Var</a></li>
              <li><a href="StringModules.htm">String Class</a></li>
              <li><a href="WixApp.htm">WixApp</a></li>
            </ul>
          </li>
          <li><a href="../../Pictures.htm">Pictures</a></li>
          <li><a href="../../SacrilegiousProgGuide/index.htm">Prog Guide</a>
            <ul id="ModulesDrop">
              <li><a href="../../SacrilegiousProgGuide/Geography.htm">Screen and Page Geography and Code Layout</a></li>
              <li><a href="../../SacrilegiousProgGuide/Naming.htm">Names and Naming Conventions</a></li>
              <li><a href="../../SacrilegiousProgGuide/Abstraction.htm">Abstraction</a></li>
              <li><a href="../../SacrilegiousProgGuide/SuccessFailure.htm">Null, Success and Failure</a></li>
              <li><a href="../../SacrilegiousProgGuide/OneEntry.htm">One Entry, One Exit (Structured Programming)</a></li>
              <li><a href="../../SacrilegiousProgGuide/HidingDetails.htm">Hiding Details</a></li>
              <li><a href="../../SacrilegiousProgGuide/Expandable.htm">Expandable</a></li>
              <li><a href="../../SacrilegiousProgGuide/qsort.htm">qsort</a></li>
              <li><a href="../../SacrilegiousProgGuide/Strings.htm">Strings</a></li>
<!--
             <li>Packages and/or Objects</li>
             <li>Loops in Objects</li>
             <li>Building Blocks</li>
             <li>Vectors (Arrays)</li>
-->
            </ul>
          </li>
        </ul>
      </div>
        </hgroup>
  </header>

  <div class="sidebar1">
    <nav>
      <ul>
        <li><a href="../../index.htm">Home</a></li>
        <li><a href="../index.htm">Modules &amp; Projects</a></li>
        <li><a href="index.htm">Coding Projects</a></li>
          <ul id="Modules">
            <li><a href="../DataBaseProjs/CodeGen.htm">CodeGen</a></li>
            <li><a href="../../SacrilegiousProgGuide/Expandable.htm">Expandable</a></li>
            <li><a href="GitPrepProject.htm">GitPrep</a></li>
            <li><a href="Library.htm">Library</a></li>
            <li><a href="MakeApp.htm">MakeApp</a></li>
            <li><a href="../../SacrilegiousProgGuide/Strings.htm">Strings</a></li>
            <li><a href="WixApp.htm">WixApp</a></li>
          </ul><br>
          
        <li><a href="../DataBaseProjs/index.htm">Data Base Projects</a></a></li>
		  <ul id="Modules">
          <li><a href="../DataBaseProjs/CodeGen.htm">CodeGen</a></li>
          <li><a href="../SJRACESProjs/RACESContacts.htm">RACES-Contacts</a></li>
          <li><a href="../SJRACESProjs/RWracesDB.htm">RWracesDB</a></li>
          </ul><br>
          
        <li><a href="../PersonalProjs/index.htm">Personal Projects</a></a></li>
		  <ul id="Modules">
<!--          <li>Address Book</li>
          <li>BkGd</li>
-->          
          <li><a href="../PersonalProjs/KeePass.htm">KeePassLastPass</a></li>
<!--      <li>Media</li>   -->
          <li><a href="../PersonalProjs/MvMp3.htm">MvMp3</a></li>
          <li><a href="../PersonalProjs/PrntProgramAndWix.htm">Print Program</a></li>
<!--      <li>Read</li>
          <li>Secure FTP</li>
-->          
        </ul><br>
          
        <li><a href="../SJRACESProjs/index.htm">SJ RACES Projects</a></a></li>
		  <ul id="Modules">
<!--      <li>ICS-211a</li>
          <li>ICS-214a</li>
-->          
          <li><a href="../SJRACESProjs/PreOutpost.htm">PreOutpost</a></li>
          <li><a href="../SJRACESProjs/RACESContacts.htm">RACES-Contacts</a></li>
          <li><a href="../SJRACESProjs/RACESdb.htm">RWracesDB</a></li>
          </ul><br>

        <li><a href="../../Pictures.htm">Pictures</a></li>
        <li><a href="../../SacrilegiousProgGuide/index.htm">Programming Guide</a></li>
        <li><a href="../../about.htm">About Bob</a></li>
      </ul>
    </nav>
  </div><!-- end .sidebar1 -->

  <article class="content"><!-- InstanceBeginEditable name="Content" -->
  <section>
    <h2>Introduction (Library 5/31/20)</h2>
    <p>
    Over a decade or so writing code on Windows for various version starting with DOS and Win 3.1.
    Every once in a while I would find a package (Ada language) that I seemed to be using over and over.
    The most basic thing in MMI is strings.  The problem in windows is that there are many, many string
    packages.  MFC uses CString, the C language implements the char for a single character and a
    zero terminated array of characters to represent a string.  Later, when Templates were introduced
    into C++ the "basic_string" class was created and with it the "string" class.  With the advent
    of Unicode the char (one Byte) became more or less deprecated, but not quite.  There are several other
    representations of a string which are needed less frequently.
    </p>
    <p>
    So, once one starts down the road of implementing a basic element of programming then other things
    need building and before long there are several modules.  Other features of the OS need interfaces
    and packages were built and used in one or more applications.  I'll try to summarize each package.
    </p>
    <p>
    Just to be clear, there is no real definition of "package" in c++.  I am using this terminology 
    to define one or more
    classes which implement some functionality.
    </p>
  </section>
  
  <section>
    <h3><a href="StringModules.htm">String Modules</a></h3>
    <p>
    The String Modules are very basic to everything in this library.  During the dark age of software 
    development there existed a language called SNOBOL.  It allowed serious manipulation of text.  It hid 
    all of the details of the operations and attributes of strings and provided very powerful operations.
    Some of the flavor of the Library String Modules were determined by SNOBOL.
    </p>
    <p>
	The String Package includes the following classes:    
    </p>
    <ul>
	<li>String -- defines a string which manages itself</li>
	<li>Cstring -- An override for CString</li>
	<li>TokenString</li>
	<li>
      ToAnsi -- A little class that transforms a Unicode (16 bit char) String to an Ansi (8 bit 
      char) String 
    </li>
	<li>ToUniCode -- A little class that transforms an Ansi string to an Unicode string.</li>
	<li>toString -- A collection of functions to translate non-string objects into a String</li>
    <li>
    RegExpr -- A class that use a Regular Expression to implement a match between a string and the regulare
    expression.
    </li>
    <li>
	LexT -- A template for implementing a lexical analyser for parsing an input stream of characters into
    tokens.
    </li>
    <li>
	CSVLex -- Comma Separated Values lines are parsed into tokens
    </li>
    </ul>
    <p>More information may be found on the <a href="StringModules.htm">String Modules page</a>.</p>
  </section>
  
  <section>
    <h3>stdafx.h</h3>
    <p>
    Well this is the Visual Studio standard include file prior to 2017.  Now it is another include
    file (i.e. pch.h, so called precompiled header file).  Several includes are included at the end of the file.
    The additions include the includes for
    the c++ packages for the string template, unicode functions and com utilities.  It also includes an author
    written include files for some typedefs (std.h), the Strings Package and the Variant package.
    I've turned off the precompiled header option in the compiler for all applications but the stdafx.h
    (or pch.h) file
    is a good place to put those header files that must appear in each compilation unit.
    </p>
  </section>
  <section>
    <h3>MapsT, MapTable, and ACEDao -- The Access Database Interface packages</h3>
    <p>
    The package is implemented with one of the older data base interface packages.  It implements several
    classes for reading and writing to tables and records in an MS Access 2016 database.  This package
    implements an interface but is very primative.  The packages MapsT and MapTable include this package
    and all programming to be simplified to tables and records in named tables.  Of course, it takes an
    application (see CodeGen) to search a database and determine all the details of the database and
    construct c++ packages that are then included in another application (see RWracesDB).
    </p>
  </section>
  <section>
    <h3>Expandable</h3>
    <p>
    Arrays are troublesome in c++.  They are fixed size.  There are some templates that implement various
    storage techniques.  However, somewhat before I discovered these features I decided to implement an
    expandable array.  The implementation is, of course, a template and there are some serious requirements
    for a successful use.
    <table width=100%>
    <tr><td><Code>Expandable&#8249;Example, 2&#8250; examples;</Code></td></tr>
    <tr><td><Code>typedef Expandable&#8249;Example, 2&#8250; Examples;</Code></td></tr>
    <tr><td><Code>Examples examples;</Code></td></tr>
    </table><br>
    </p>

    <p>
      Note the s at the end of the example and Examples.  This is to suggest multiple numbers of an Example.
      An Example must be a typedef, struct or class.  It defines what one entity of examples is.  The typical
      way examples is used is to index into a specific example:  examples[3] is the fourth entity in the array.
    </p>
    <p>
    To implement the expansion (which is automatic) the Example class must implement a copy constructor and
    an operator= (assignement).  Furthermore, if the content of the array is a pointer to an object, then
    the destructor of the of the Example cannot delete (release) the object of the pointer.
    </p>
    <p>
    The size changes when a request for an entry in the array exceeds the current size.  The size is doubled
    each time it is increased and the contents are copied from the old version to the new version.  Just to
    be clear, the actual address of an entry in this array may change with an entry.  Don't save pointers to
    the entries unless there are to be no more additions.
    </p>
    <p>
    The current number of actual entries in the array is given by "examples.end()"  This is also the index
    of the next unused entry in the array.  The way an example is added to the array is usually done with:
    <table width=100%>
    <tr><td><Code>examples[examples.end()] = myNewExample;</Code></td></tr>
    </table><br>
    </p>

    <p>
      myNewExample contains some data which needs to be placed at the end of the array.  The function end()
      gives the index of the first unused entry in the array and the copy operation copies the data.  The
      brackets function figures out if the array is too small and expands if as needed.  Just using
      ordinary array access will achieve the desired goal.
    </p>
    <p>
    An implementation note:  When the actual storage is increased in size (doubled) the constructor for every
    element in the new array is called.  When the storage is released the destructor for every element of the array
    is called.  This is true when an expansion takes place as well as when the object is released implicitly
    or explicitly.  During expansion the old version of the array is returned to the heap but just before the
    storage is released the destructor is called to release any objects in the elements of the array.
    </p>
  </section>
  <section>
    <h3>CDoc Package</h3>
    <p>
    With advent of Unicode I was faced with a dillema concerning the content of files and the character size in an
    application.  It led me to develop a strategy of quickly pushing the details of the transformation of the
    characters to some packages that can be easily added to a new application.  This led to a sub class of CDocument
    which would eventually lead to some standard IO funtions with little change to the overall organization of a
    Document in the MFC single doc application.
    </p>
    <p>
    When VS17 creates a doc class if makes the doc class a sub-class of CDocument.  Then it provides functions in
    the doc class so that the doc class can perform input/output functions.  The programmer must replace CDocument
    with CDoc so that input/output between the application and a file may ignore the character size issue.
    </p>
    <p>
    CDoc replaces 4 functions of CDocument with its own brand of IO:
    <ul>
    <li>OnOpenDocument -- Opens a file for reading and calls serialize</li>
    <li>OnSaveDocument -- Opens a file for writing and calls serialize</li>
    <li>DoFileSave -- Opens a file for writing and calls serialize</li>
    <li>serialze -- A virtual function (i.e. must be implemented in sub-class) with a new Archive argument</li>
    </ul>
    </p>
    <p>
    As you can see, the MFC CArchive class has been replaced with a home-grown class, Archive.
    So the Doc class
    must delete the C in CArchive to get the benefit of CDoc.  Once that is done, then the Archive
    class is available
    for further implementation.
    <table width=100%>
    <tr><td><Code>virtual void serialize(Archive& ar);</Code></td></tr>
    </table><br>
    </p>

    <p>
      The Archive package is strictly a front end for the FileIO package.  The Archive package
      provides basic read/write
      operations as well as attributes concerning being opened, loading or storing.  It also
      provides the "&#8249;&#8249;" operator
      for Unicode characters and strings (which I haven&acute;t expanded to include other types).
      All the hard work is
      performed in the FileIO package.  It performs buffered IO operations along with the translation
      from 8 bit to
      16 bit characters.  It is complete enough to be used independently of the CDoc and Archive.
    </p>

  </section>
  <section>
    <h3>CScrView</h3>
    <p>
    When VS17 produces a one document, one window application the View package is populated with a few functions
    that provide the functionality to draw on the window and to provide basic printing functions.  Over the years
    I developed a package (called DisplayView if I recall correctly) that did the bulk of the job using a
    linked list
    of display entities (attributes and text) as the basis of what was to appear on the window.  It also allowed
    the window to be printed in the standard MFC way (Setup, Preview and Print).  When I started writing this
    document I realized that CDoc was a subclass of CDocument and the DisplayView functions could be turned into a
    subclass of CScrollView.  That has happened and CScrView is the result.
    </p>
    <p>
    This class only works with one document/one View applications as far as I know.  Right after creating the
    application (MFC, One Document, View based on CScrollView) most of the guts of the AppView.h and AppView.cpp
    is deleted and all mention of CScrollView is replaced with CScrView.  Then anything sent to NotePad is
    displayed
    on the view (usually have to execute an invalidate() to get the view repainted).
    Furthermore, the print commands
    just print whatever is in the view (even the hidden sections).  I suggest looking at MakeApp or TestApp in the
    MakeApp solution for an example of a view.
    </p>
    <p>
    There is one function that may be called explicitly by the user.
    <table width=100%>
    <tr><td><Code>void setFont(  TCchar* f, int points = 120)</Code></td></tr>
    </table><br>
    </p>

    <p>
    The font size is code in tenths of a point.  Should the user actually ask for a 12 point font by
    using setFont(Arial, 12) the function bumps it by 10 (if the fontSize argument is less than 70 it
    is multiplied by 10).
    </p>
    <p>
    All the other functions are utilized either by MFC or functions defined elsewhere.
    </p>
  </section>
    <section>
    <h3>CApp</h3>
    <p>
    Once a program learns a new trick it is applied everywhere!  CApp supplies some much needed capability
    to the VS17 generated Application (Main Program in C terms, Main Object in c++ terms).  For example, the
    constructor for CApp will create a "application identifier" from the resource (.rc) file using the
    CompanyName. ProductName and Version which are defined in the rc file.
    </p>
    <p>
    MFC allows one to write into the Title Bar of the window.  However in a Doc/View application the window
    is the MainFrame.  furthermore, MFC seems determined to write into the title bar itself.  So a kludge has
    been devised involving a CMainFrm subclass of CFrameWndEx that allows one to write the title in one
    call or two calls:
    <table width=100%>
    <tr><td><Code>setAppName(&#8249;appName&#8250;);  setTitle(&#8249;title&#8250;);</Code></td></tr>
    </table><br>
    </p>

    <p>
    If the setTitle function is used alone then the &#8249;title&#8250; appears on the title bar of the main
    window of the app.
    If both functions are utilized, the title bar shows :&#8249;appName&#8250; -- &#8249;title&#8250;".
    </p>
    <p>
    CApp facilitates calling the functions in CMainFrm by finding the pointer to the mainframe and calling
    the corresponding function.
    </p>
    <p>
    Three other functions are very useful in MFC applications.  CApp contains:
    <table width=100%>
    <tr><td><Code>CDocument* getDoc();</Code></td></tr>
    <tr>
      <td><Code>CView*     &nbsp;&nbsp;&nbsp;&nbsp;getView();</Code></td></tr>
    <tr>
      <td><Code>void       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalidate();</Code></td></tr>
    </table><br>
    </p>

    <p>
    Access to these functions is provide in the main App by some simple functions:
    <table width=100%>
    <tr><td><Code>MakeAppDoc*  &nbsp;doc()  &nbsp;{return (MakeAppDoc*)&nbsp;  CApp::getDoc();}</Code></td></tr>
    <tr><td><Code>MakeAppView* view() {return (MakeAppView*) CApp::getView();}</Code></td></tr>
    </table><br>
    </p>

    <p>
    And finally to make them visible through the entire application the following inline functions are
    usually defined:
    <table width=100%>
    <tr><td><Code>inline void         invalidate() {theApp.invalidate();}</Code></td></tr>
    <tr><td><Code>inline MakeAppDoc*  doc()  {return theApp.doc();}</Code></td></tr>
    <tr><td><Code>inline MakeAppView* view() {return theApp.view();}</Code></td></tr>
    </table><br>
  The only reason for the functions in the App package is to translate the MFC pointers to the app's
    subclasses (e.g. MapkAppDoc* and MakeAppView*).
    </p>
  </section>
  <section>
  <h3>CMainFrm</h3>
  <p>
  CMainFrm adds only the functions:
  <table width=100%>
  <tr><td><Code>void setAppName(TCchar* name);</Code></td></tr>
  <tr><td><Code>void setTitle( &nbsp;TCchar* rightPart);</Code></td></tr>
  </table><br>
  </p>
  </section>
  <section>
  <h3>NotePad, Note, DisplayDev, Display, FontMgr, and Node</h3>
  <p>
    CScrView uses the DisplayDev, Display and FontMgr packages to display in the view window and print the content
  of the
  view window.  In the Document package and other places in the program the NotePad provides a set of operations
  to write to the view.  NotePad is instantiated once, the object is named "notePad".  notePad implements
  many streaming output operators (i.e. "&#8249;&#8249;"). Furthermore, there are tab, font and some other
  stream modifiers.
  </p>
  <p>
    NotePad is implemented with a linked list.  The Note object contains everything there is to know about output
  of one text sequence and any relevant modifiers.  The Note object includes the Node Package.  The Node package
  implements a single pointer linked list using C like code (since it was implemented first back in the "C" days).
  </p>
  </section>
  <section>
    <h3>GetPathDlg, FileIO, filename, filePaths, filesrch and SrchFile</h3>
  <p>
    These packages provide various services with respect to the file system.  Some are quite old written in the
  "C" days.  Others utilize c++ to advantage.  One of the packages uses the "match" package, a regular expression
  search algorithm.
  </p>
  </section>
  <section>
    <h3>Archive -- A Replacement for CArchive</h3>
  <p>
  The document class, CDoc, that is subclassed from CDocument implements a feature of CDocument that I had trouble with.
  CDocument was written back in the day when ASCII characters were always 8 bits (earlier they had been 6 bits, then 7 bits and
  finally someone notice powers of 2 in computing and characters became 8 bits and internal word size became powers of 2, i.e.
  16, 32, 64 bits).  With the advent of computing world wide, character size had to change.  The Unicode character set is
  used in this library (mostly because VS17 seems to favor it).  However garden variety files still use 8 bit characters.
  </p>
  <p>
  Since there must be a translation between ANSI, 8 bit characters, and Unicode, 16 bit characters when reading and writing to
  files I decided that it would be done at the actual reading and writing of data from/to the file.  This required modifying
  the serialize function in the CDocument module in an application.  The easiest way to do that was replace the CArchive package.
  Thus Archive was invented.
  </p>
  <p>
  The CDoc subclass of CDocument implements the virtual functions for OnNewDocument, OnNewDocument, OnNewDocument and serialize.
  The three former functions open or creates the files and calls serialize with an Archive object all ready to read or
  write from/to the file.  Archive presents a streaming output interface as well as traditional read and write functions.  There
  are some functions to support tabbing in the file by counting characters.
  </p>
  <p>
  The library includes on package that implements use of Archive to do input/output, namely the NotePad package.  Here is the
  code in the TestAppDoc module (see MakeApp application) for utilizing the NotePad archive functions:
    <table width=100%>
    <tr><td><Code>void TestAppDoc::serialize(Archive& ar) {</Code></td></tr>
    <tr><td><Code>&nbsp;&nbsp;if (ar.isStoring()) {notePad.archive(ar); return;}</Code></td></tr>
    <tr><td><Code></Code></td></tr>
    <tr><td><Code>Tchar  ch;</Code></td></tr>
    <tr><td><Code>String s;</Code></td></tr>
    <tr><td><Code></Code></td></tr>
    <tr><td><Code>&nbsp;&nbsp;while (ar.read(ch)) {</Code></td></tr>
    <tr><td><Code>&nbsp;&nbsp;&nbsp;&nbsp;if (ch == _T('\n'))</Code>
                                                   {notePad << s << nCrlf;  s.clear(); continue;}</Code></td></tr>
    <tr><td><Code>&nbsp;&nbsp;&nbsp;&nbsp;if (ch == _T('\r')) continue;</Code></td></tr>
    <tr><td><Code>&nbsp;&nbsp;&nbsp;&nbsp;s += ch;</Code></td></tr>
    <tr><td><Code>&nbsp;&nbsp;&nbsp;&nbsp;}</Code></td></tr>
    <tr><td><Code></Code></td></tr>
    <tr><td><Code>&nbsp;&nbsp;if (!s.isEmpty()) notePad << s << nCrlf;</Code></td></tr>
    <tr><td><Code></Code></td></tr>
    <tr><td><Code>&nbsp;&nbsp;invalidate();</Code></td></tr>
    <tr><td><Code>&nbsp;&nbsp;}</Code></td></tr>
    </table><br>
  This particular code segment treates the file as just a sequence of lines.  However very often the
  file is parsed in some way upon input from the file.  If the notePad object is the destination for the
  results of parsing the input, then the notePad streaming input functions are useful for storing the data.
  At other times some other data structure is used for storing the input and the serialize function is
  used to implement the transfer from the file to the data sturcture.
  </p>
  </section>
  <section>
    <h3>LexT, Csv and Token Packages</h3>
  <p>
    An input stream is often needed to be split up into discernable units.  Compilers usually call these units "tokens".
  LexT is a template for breaking an input stream into tokens.  A Token is a string, sometimes a value and a code (enum value)
  that identifies the type of token.  LexT requires the user to classes to determine input and output and also requires some
  information about some processing details.  These packages are not being used in any applications at the time of writing.
  </p>
  </section>
  <section>
  <h3>match Package</h3>
  <p>
  Regular Expressions can express some interesting patterns.  The match.h header file lists the special
  characters in the pattern.  The pattern is built in an object and then that object is used to match (or
  not match) any string that is presented to it.
  </p>
  </section>
  <section> </section>
  <section> </section>
  <section> </section>
  <section> </section>
  <!-- InstanceEndEditable --></article>
  <!-- end .content -->

  <footer>
    <hr />
    <div>
      <a href="../../index.htm">Home</a>&nbsp;&nbsp;
      <a href="../index.htm">Modules</a>&nbsp;&nbsp;
      <a href="../../Pictures.htm">Pictures</a>
      <a href="../../SacrilegiousProgGuide/index.htm">Prog Guide</a>
    </div>
    <div>eMail: romeo romeo victor tango alpha tango sam whiskey delta echo dot charlie oscar mike</a></div>
    <div>Last modified:&nbsp; <!-- #BeginDate format:Am2 -->10/23/23<!-- #EndDate --></div>
    <div align="center">Copyright SD&E.&nbsp; All rights reserved.</div>
  </footer>
  <!-- end .container -->
</div></body>
<!-- InstanceEnd --></html>
