<!DOCTYPE HTML>
<html lang="en"><!-- InstanceBegin template="/Templates/pageGuide.dwt" codeOutsideHTMLIsLocked="false" -->
<head>

<meta charset="utf-8">
<!-- InstanceBeginEditable name="doctitle" -->
<title>Expandable Array</title>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="head" -->
<!-- InstanceEndEditable -->

<link href="../stylesheet.css"    rel="stylesheet" />
<link href="../Graphics/Icon.ico" rel="shortcut icon" />

<!--[if lte IE 7]>
<style>
.content { margin-right: -1px; } /* this 1px negative margin can be placed on any of the columns in
                                                                        this layout with the same corrective effect. */
ul.nav a { zoom: 1; }                    /* the zoom property gives IE the hasLayout trigger it needs to correct
                                                                        extra whiltespace between the links */
</style>
<![endif]-->

<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

<script type="text/javascript">
function MM_jumpMenu(targ,selObj,restore){ //v3.0
  eval(targ+".location='"+selObj.options[selObj.selectedIndex].value+"'");
  if (restore) selObj.selectedIndex=0;
}
</script>
</head>

<body>

<div class="container">

  <header>
    <hgroup>
      <a href="../index.htm" id="LogoLink"><img src="../Graphics/swdeLogo200.jpg" alt="Logo" /></a>
      <div class="TitleBlock">
        <a href="../index.htm">
            <h1>Software Design &amp; Engineering</h1>
            <h1>
                    <!-- InstanceBeginEditable name="PageTitle" -->
            Expandable Array (Vector)
          <!-- InstanceEndEditable -->
          </h1>
        </a>
      </div>
      <div class="TitleBlock" id="DropDown">
        <ul>
          <li><a href="../index.htm">Home</a></li>
          <li><a href="../Modules/index.htm">Modules</a>
            <ul id="ModulesDrop">
              <li><a href="../Modules/PersonalProjs/KeePass.htm">KeePass/LastPass</a></li>
              <li><a href="../Modules/CodingProjs/MyLibrary.htm">Library</a></li>
              <li><a href="../Modules/PersonalProjs/MvMp3.htm">Move Mp3 Tracks</a></li>
              <li><a href="../Modules/SJRACESProjs/PreOutpost.htm">PreOutpost</a></li>
              <li><a href="../Modules/PersonalProjs/PrntProgramAndWix.htm">Print Program (pp)</a></li>
              <li><a href="../Modules/SJRACESProjs/RWracesDB.htm">Read/Write RACES DB</a></li>
              <li><a href="../Modules/PersonalProjs/PrntProgramAndWix.htm#SetEnv">Set Environment Var</a></li>
              <li><a href="../Modules/CodingProjs/StringModules.htm">String Class</a></li>
              <li><a href="../Modules/CodingProjs/WixApp.htm">WixApp</a></li>
            </ul>
          </li>
          <li><a href="../Pictures.htm">Pictures</a></li>
          <li><a href="index.htm">Prog Guide</a>
            <ul id="ModulesDrop">
              <li><a href="Geography.htm">Screen and Page Geography and Code Layout</a></li>
              <li><a href="Naming.htm">Names and Naming Conventions</a></li>
              <li><a href="Abstraction.htm">Abstraction</a></li>
              <li><a href="SuccessFailure.htm">Null, Success and Failure</a></li>
              <li><a href="OneEntry.htm">One Entry, One Exit (Structured Programming)</a></li>
              <li><a href="HidingDetails.htm">Hiding Details</a></li>
              <li><a href="Expandable.htm">Expandable</a></li>
              <li><a href="qsort.htm">qsort</a></li>
              <li><a href="Strings.htm">Strings</a></li>
<!--
             <li>Packages and/or Objects</li>
             <li>Loops in Objects</li>
             <li>Building Blocks</li>
             <li>Vectors (Arrays)</li>
-->
            </ul>
          </li>
        </ul>
      </div>
        </hgroup>
  </header>

  <div class="sidebar1">
    <nav>
      <ul>
        <li><a href="../index.htm">Home</a></li>
        <li><a href="../Modules/index.htm">Modules &amp; Projects</a></li>
        <ul id="Modules">
        <li><a href="../Modules/CodingProjs/index.htm">Coding Projects</a></li>
        <li><a href="../Modules/DataBaseProjs/index.htm">Data Base Projects</a></li>
        <li><a href="../Modules/PersonalProjs/index.htm">Personal Projects</a></li>
        <li><a href="../Modules/SJRACESProjs/index.htm">SJ RACES Projects</a></li>
        </ul>
        <li><a href="../Pictures.htm">Pictures</a></li>
        <li><a href="index.htm">Programming Guide</a></li>
          <ul id="Modules">
            <li><a href="Geography.htm">Screen and Page Geography and Code Layout</a></li>
            <li><a href="Naming.htm">Names and Naming Conventions</a></li>
            <li><a href="Abstraction.htm">Abstraction</a></li>
            <li><a href="SuccessFailure.htm">Null, Success and Failure</a></li>
            <li><a href="OneEntry.htm">One Entry, One Exit (Structured Programming)</a></li>
            <li><a href="HidingDetails.htm">Hiding Details</a></li>
            <li><a href="Expandable.htm">Expandable</a></li>
            <li><a href="qsort.htm">qsort</a></li>
            <li><a href="Strings.htm">Strings</a></li>
<!--        <li>Packages and/or Objects</li>
            <li>Vectors (Arrays)</li>
            <li>Loops in Objects</li>
            <li>Building Blocks</li>
-->
          </ul>
        <li><a href="../about.htm">About Bob</a></li>
      </ul>
    </nav>
  </div><!-- end .sidebar1 -->

  <article class="content"><!-- InstanceBeginEditable name="Content" -->
  <section>
    <h2>Expandable</h2>
    <p>
        Expandable.h may be found in the Library.  It provides a feature that I've implemented
      several times although this one is better that the past versions.
    </p>
    <p>
    Templates are a fairly recent C++ invention (considering that programming languages started
    around the late 50s).  The idea is simple:  Write a description of an algorithm or group of
    algorithms that may be applied to any class of objects.  An example might be a sorting algorithm.
    This is a single algorithm but it is complicated to get right.  It would be nice to be
    able to do a qsort on an array of say, integers and strings and class objects.  Sorting
    requires some sort of selection mechanism like "greater than" and an assignment operator
    like "=".  But each of the objects suggested above have really different selection and assignment
    operators.  So, the template allows the objects do define their own operations while the
    basic sorting algorithm does its work deciding how the items should be sorted.
    </p>
    <p>
    In the C language arrays are statically defined.  They are fixed in length.  So the programmer is
    left with very little option but to make really large arrays to avoid overflow.  Not a good choice.
    Expandable at a run time cost avoids that dilemma.  The declaration for an expandable array is:

    <blockquote>
    <TableCode>
    Expandable&lt;String, 2&gt; ex; </TableCode>
    </blockquote>

    <p>
        The idea of expandable is that the square bracket operator always finds a way to store or retrieve
    the content of the array.  In the example above, the content is a simple string.  The mechanisms are
    hidden from the user but there is a gotcha.  The content of the array must be  a class (or struct).
    The class must have a copy constructor and an assignment operator.  In the above example, String is
    the class, so the following functions must appear in the String class:
    </p>

    <blockquote>
    <TableCode>
    class String {<br/><br/>
    Mumble mumble;<br/><br/>
    public:<br/><br/>
    &nbsp;&nbsp;String() : mumble(...) {...}<br/>
    &nbsp;&nbsp;String(String& s) {copy(s);}<br/><br/>
    &nbsp;&nbsp;String& operator= (String& s) {copy(s); return *this;}<br/><br/>
    private:<br/><br/>
    &nbsp;&nbsp;void copy(String& s) {mumble = s.mumble;}<br/>
    &nbsp;&nbsp;}<br/>
    </TableCode>
    </blockquote>

        <p>
    The expandable template takes care of all the details of managing the array.  So when ex[0] is assigned
      string, it is stored.  When ex[1] is assigned a string it is stored.  However, when ex[2] is assigned
    a string there is no place to store it as only two elements were created with the declaration.  So
    Expandable increases the size of the array.  Of course it must copy all the existing elements to the new
    version of the array.  That is one of the hidden costs mentioned earlier.  After the copy of all the
    strings in the array the old array must be deleted (or a memory leak will occur), another cost.
    </p>

    <p>
    There is one other problem with Expandable.  In this example defines an array, "ex", which is composed of
    String objectsif is possible to reference an array element as follows:
        </p>
    <blockquote>
    <TableCode>
    String& s = ex[0];<br>
    &nbsp;&nbsp;ex[3] = _T("Nonsense");<br>
    &nbsp;&nbsp;s = _T(&quot;This assignment will likely cause an exception&quot;);
    </TableCode>
    </blockquote>

<p>
The reference s is to the first element of the array ex.
So far the array ex doesn't look too interesting.  The fourth element of the array (i.e. ex[3]) is set to "Nonsense"
(the _T("") creates an Unicode string).  Unfortunately it also requires an expansion of the array and a copy of the
string in the first element of the array.  So the reference in s is no longer valid and will likely cause an exception.
That is because between the time the reference was created and the time of the assignment the vector was copied to a new
location in the heap.  This issue is dealt with better by the ExpandableP template.
</p>

<p>
Where it becomes interesting is when I try to put
100 strings into it.  Behind the scene ex expands to accomodate the 100 strings.  It does this by quietly
increasing the size of the array as new elements are added to the array that exceed the current size of the
array.  It is still an array, one can qsort it, one can index into it, one can loop over all the elements
forward, backward and randomly. </p>
<p>
Well that solves the overflow problem of C style arrays.  What is the cost of this?  The cost includes the
requirement that any entity (class or typedef) must have four specific operations.  A class Data,
e.g. class Data {...}, must have the following "methods" or functions:
</p>
<ul>
<li>Constructor with no argument, e.g. Data(), which initializes all components of the class</li>
<li>
Copy Constructor, e.g. Data(const Data& d), which copies all components of object d to
object *this
</li>
<li>
Assignment operator, e.g. Data& operator= (Data& d), which copies all components of object d to
object *this and returns *this</li>
<li>
Destructor, e.g. ~Data() that releases objects obtained from the heap and zeros all data
components</li>
</ul>
<p>
Furthermore, the Expandable Template requires a "method" to compute the index each and every time
so that overflow is detected and avoided.  It avoids overflow by creating a new array block double in
size of the current array block and copying all the data from the current block to the new block.
Expensive, you say, yep.  But bloody convenient to know that there can never be overflow!  And it can
be sorted too.  Loops are easy, it is just an indexed array.
</p>
<p>
Is there any way to cut the overhead down?  Yes, just make the expandable array contain pointers to the data.
Then the only copying required is a pointer.  For big complicated data structures that makes the cost quite
reasonable.  However, for simpler structures with better guesses about size, one can just put the structure
in the array and be done with it.
<h2>ExpandableP</h2>
</p>
<p>
The idea of an array of pointers to cut the overhead of copying the data when expanding the array was
enough incentive to create a template to do just that.  But it turns out that having an array of
pointers made the destructor a bit clumsy.  So another template is required to manage the pointers:
</p>
<blockquote>
<TableCode>
class Datum {<br>
private:<br>
Key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   value;<br>
String&nbsp;&nbsp;   name;<br>
public:<br>
<br>
&nbsp;&nbsp;Datum() : value() { }<br>
&nbsp;~Datum() { }<br>
&nbsp;&nbsp;&nbsp;o o o<br>
&nbsp;&nbsp;};<br>
<br>
<br>
typedef DatumPtrT&lt;Datum, Key&gt; DatumP;<br>
<br>
<br>
class MyClass {<br>
ExpandableP&lt;Datum, Key, DatumP, 2&gt; data;<br>
public:<br>
<br>
&nbsp;&nbsp;MyClass() { }<br>
&nbsp;~MyClass() { }<br>
&nbsp;&nbsp;&nbsp;o o o<br>
&nbsp;&nbsp;}
</TableCode>
</blockquote>
<p>
The Record Pointer (i.e. DatumP) defined by the DatumPtrT Template (i.e. DatumPtrT) does all the right things
when the expandable array needs to be expanded.  The actual data node (i.e. Datum) is just moved from one
array to another during the expansion.  Furthermore, creating a reference to an element in the array just creates
a reference to the node in the heap which is never moved or changed.
</p>

<p>
The Datum pointer class created by DatumPtrT needs the type or class of the Key used in the find and binary search
methods.  The Key class may be a simple object like String or int or it may be a user define class with the appropriate
boolean operations defined in any way that the user desires.  If the find or binary search are not required then a
sinple int as template argument is sufficient.
</p>

<h2>ExpandableP</h2>

<p>
ExpandableP  includes a class Key used as a key object in the Datum object.
In Expandable and ExpandableP Templates the key used for insertion sort is any single object in the Datum object.
Usually it is a String which holds something like the path of a file or name of the object.  ExpandableP allows one
to have a more complex object as the key, for example a boolean and a string.  Here is an example declaration:
</p>

<blockquote>
class SiteFileDsc {<br/>
SiteFileKey key;<br/>
  o o o<br/>
  };<br/><br/>


class SiteFileDscs;<br/><br/>

typedef DatumPtrX&lt;SiteFileDsc, SiteFileKey&gt; SiteFileP;<br/>
<br/>
typedef IterT&lt;SiteFileDscs, SiteFileDsc&gt;&nbsp;&nbsp;&nbsp;&nbsp;FileDscsIter;
&nbsp;&nbsp;&nbsp;// Iterator Declaration<br/><br/><br/>

class SiteFileDscs {<br/>
<br/>
o o o<br/>
<br/>
ExpandablePX&lt;SiteFileDsc, SiteFileKey, SiteFileP, 2&gt; data;             // List of all files<br/>
<br/>
&nbsp;&nbsp;o o o<br/>
&nbsp;&nbsp;}
</blockquote>

<h2>Available Operations on an Expandable, ExpandableP or ExpandableP Vector</h2>
<p>
When there is an Expandable vector, data, containing elements of class Datum
</p>
<blockquote>
Expandable&lt;Datum, 2&gt; data;<br/>
Datum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datum;
</blockquote>

<p>
The following operations are available:
</p>
<ul>
<li>datum = data[i]; -- where 0 <= i < endN</li>
<li>data[i] = datum; --  array expands to encompass i</li>
<li>data.clear(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- content is ignored but number of elements is set to zero</li>
<li>
data = datum; &nbsp;&nbsp;&nbsp;-- &nbsp;datum is inserted (copied) into the sorted array at the correct
position
</li>
<li>data = &amp;datum;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&gt;=" and "==" operators in datum must be defined</li>
<li>data += datum;&nbsp; -- datum is appended (copied) to array (at a new last element)</li><br/>
<li>
Datum& d = data.nextData(); -- A reference to new last element of array is returned.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It may used as shown or immedialy with a dot operator or even as a target of</li>
<li>data.nextData() = _T("xxx"); &nbsp;-- an assignment (where a Datum operator= is defined)</li><br/>
<li>
data(i, datum); &nbsp;&nbsp;-- datum is inserted at index i, the contents at i and above are moved up one element </li>
<li>
data.del(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- The datum at index i is deleted and the elements above are moved
down to fill in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the hole.  The number of elements in the array is reduced by one </li>
</ul><br/>

<p>
Generally, the ExpandableP and ExpandableP templates have the same operations, except for some suble differences.  The assignement
operator allows the datum to decide where the datum is stored by the definition of ">=" and "==" operators.
</p>

<ul>
<li>data = &datum;&nbsp;&nbsp; -- In ExpandableP it is assumed that datum has been allocated from the heap and a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointer
to it is placed in the array. In Expandable it is copied into the array.</li>
<li>data = datum;&nbsp;&nbsp; &nbsp;&nbsp;-- The datum is assumed to be local variable of some kind and so
  it is copied into the<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array. In ExpandableP a node is allocated prior to the copy operation.</li>
</ul><br/>
<p>
The append operator "+=" places the node at the entry one element beyond the last entry in the array, i.e. appends.
</p>
<ul>
<li>data += &datum;&nbsp;-- In ExpandableP the node is already allocated</li>
<li>data += datum;&nbsp;&nbsp;&nbsp;-- In ExpandableP the node is allocated before the datum is copied into the array.</li>
<br/>
<li>
Datum& d = data.getData(i); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- return a reference to a record at index i allocating a
record if necessary </li>
</ul><br/>
<p>
The function operator is used to "insert" a datum into an array at index i after moving other entries out of the way.
No entries in the array before the insertion are lost.
</p>
<ul>
<li>data(i, &datum);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- In ExpandableP the node is already allocated
</li>
<li>data(i, datum);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- The datum is copied into the array at index i
</li>
</ul><br/>
<p>
In ExpandableP nodes in the array may be allocated and deallocated explicitly with the following functions.  They can be populated
outside of the array and either added to the array later or sent back to the heap.
</p>
<ul>
<li>Datum* d = data.allocate();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Allocate one record and return a pointer to it</li>
<li>data.deallocate(&datum);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Deallocate one record</li>
</ul><br/>
<p>
When using ExpandableP, infrequently one must manipulate the actual pointer in the array that points to the
datum.
</p>
<ul>
<li>RcdPtr* rcdP = data.getRcdPtr(i);&nbsp;-- Returns a pointer to a RcdPtr class -- use in moderation</li>
</ul><br/>

<h2>Insertion Sort</h2>
<p>
Suppose one needs the data to be sorted on the value of one of the components of the Datum class.
One method of achieving that goal is to insert the datum using an insertion sort.  Yep it is expensive because the
elements need to be moved during the insertion.  However, in small vectors this is not really noticeable and it
is very convenient.
</p>
<p>
The Datum class (or struct) must have the following method:
</p>
<ul>
<li>datum1 >= datum2</li>
</ul><br/>
<p>
Here is an example:
</p>
<blockquote>
struct Datum {<br/>
String name;<br/>
uint&nbsp;&nbsp; attr;<br/>
<br/>

&nbsp;&nbsp;Datum() : attr(0) { }<br/>
&nbsp;&nbsp;Datum(Datum& d) {copy(d);}<br/>
&nbsp;~Datum() { }<br/>
<br/>
&nbsp;&nbsp;Datum& operator=  &nbsp;(Datum& d) {copy(d); return *this;}<br/><br/>
&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;operator>= (Datum& d) {return name >= d.name;}<br/><br/>
private:<br/>
&nbsp;&nbsp;void copy(Datum& d) {name = d.name; attr = d.attr;}<br/>
&nbsp;&nbsp;};<br/>
</blockquote>

<p>
Above when describing the assignment operator "data = datum" I was vague about where the insertion
of the data would take place.  When the operator ">=" is defined in the datum then the assignment
operator on the data will result in an insertion sort.
</p>

<h2>Destructor</h2>
<p>
The Expandable and ExpandableP destructors free the allocated datafor which they are responisble for
allocating.
In addition they will call the destructor for each node in the active part of the array.  So, ...
if the nodes take care of freeing any data allocated during the execution of the application then
there should be no memory lost.  Big if, take care.
</p>

<h2>Iterators</h2>
<p>
One day I got tired of creating for loops for an expandable array.  First one needs to find the current number
of elements in the array.  Then a loop is created with an index that ranges from zero to just less than the the
number of elements.  This two step process still left one with the job of indexing into the array to accomplish
any task.  By the way, I came on this idea by using one of the MFC facilities for accessing the Microsoft ACCESS
database.
</p>
<p>
Anyway, this is certainly a simpler version of an iterator over a vector.  I created a template to iterate over
an expandable array provided there was one such array in the class.  Let me digress for a moment to comment on
the last sentence.
</p>

<p>
C++ classes are created for a variety of reasons.  One reason may be to process and/or store some data.  Rather
than sticking a data structure in a global location it might be better to shield the data from the rest of the
program (i.e. hide it).  So stick the data in a class.  Suppose one has two kinds of data that needs storing.
Why not share the class?  Well that violates the "object" prinicple.  One data thingy plus all the operations
one can think of on the data is all that should be in a single class, period.  Doesn't mean only one variable,
just one data thingy.
</p>

<p>
So for the most purposes when using an Expandable data structure there should only be one in the class.  Then
an iterator on that expandable data structure is fairly easy to implement with a friend class and some little
private helper functions in the class with the expandable data structure.  The implementation uses a template
for creating the friendly iterator class and a cut and paste will add the private helper functions to the
class with the expandable data structure.
</p>

<p>
The implementation details can be found in the Library, but for now I'll just show how to use it:
</p>
<blockquote>
Datum* find(String name) {<br>
MyDataIter iter(myObject);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// where myObject is an object of MyClass<br>
Datum*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datum;<br>
<br>
&nbsp;&nbsp;for (datum = iter(); datum; datum = iter++) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (datum->name == name) return datum;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>
&nbsp;&nbsp;return 0;<br>
&nbsp;&nbsp;}
</blockquote>
<p>
MyDataIter is either a class or a typedef and requires the name of the object to iterate over.  Both
iter() and iter++ return a pointer to a datum or return zero (i.e. null, NULL, 0).  Zero is interpreted as
the end of the array in the loop, i.e. false in the for conditional segment.  So the body of the loop
is assured of having a real "datum" pointed to by the datum variable.
</p>
<p>
The iterator is useful because the mechanism for controlling the point in the array to reference is contained in
the iterator not in the object holding the data.  So having two iterations over the same data are possible and they
do not interfere with each other (unless there is a lot of adding and deleting happening).
</p>
<p>
The idea worked so well that for an array I added a reverse iteration (i.e. iter--)and deleting an object in the array and
collapsing the array to fill in the hole.
</p>
<p>
Then I noticed that other data structures could be managed this same way.  So I added an iterator with identical
use (though not identical implementation) for the linked list in the library.  When I come across other data
structures that lend themselves to this approach I generally create a class that will contain the
iteration mechanisms.  Be aware though that adding and deleting may cause problems with iteration (even with
just one iterator, think hard about those operations).
</p>
<p>
Expandable and ExpandableP have nearly identical data structures so an iterator template is possible with one hidden change in the 
class containing the expandable array.  Here is how to define the iterator:
</p>
<blockquote>
class Datum {<br>
&nbsp;&nbsp;o o o<br>
&nbsp;&nbsp;}<br><br><br>

class MyObject;<br>
typedef IterT&lt;MyObject, Datum&gt; MyDataIter;<br>
<br><br>

class MyObject {<br>
Expandable&lt;Datum, 2&gt; data;<br>
&nbsp;&nbsp;o o o<br><br>
public:<br>
&nbsp;&nbsp;o o o<br><br>
private:<br><br>

&nbsp;&nbsp;// returns either a pointer to data (or datum) at index i in array or zero<br>
&nbsp;&nbsp;// return &amp;data[i] for Expandable or data[i].p for ExpandableP<br><br>
&nbsp;&nbsp;Datum* datum(int i) {return 0 <= i && i < nData() ? &data[i] : 0;}<br><br>       

&nbsp;&nbsp;int    nData()      {return data.end();}&nbsp;&nbsp;// returns number of data items in array<br><br>

&nbsp;&nbsp;friend typename MyDataIter;<br>
&nbsp;&nbsp;}
</blockquote>
</section>
<section>
<h2>Some Details Required to Use Expandable</h2>
<p>
This next section need not be read until one would like to use the implementation of one of the Expandable Templates.
</p>
<h3>Setting up an Expandable Array (Vector)</h3>
<blockquote>
Expandable&lt;Datum, 2&gt; data;<br/>
or<br/>
typedef Expandable&lt;Datum,2&gt; Data;
</blockquote>
<p>
  where Datum is a class, e.g. class Datum {...}, and requires the following methods</p>
<ul>
<li>Constructor with no argument, e.g. Datum(), which initializes all components of the class</li>
<li>Copy Constructor, e.g. Datum(const Datum& d), which copies all components of object d to
object *this</li>
<li>Assignment operator, e.g. Datum& operator= (Datum& d), which copies all components of object d to
object *this and returns *this</li>
<li>Destructor, e.g. ~Datum() that releases objects obtained from the heap and zeros (optionally) all data
components</li>
</ul><br/>
<p>
Here is an example of the minimum Datum class (or struct):
</p>

<blockquote>
struct Datum {<br/>
String name;<br/>
uint&nbsp;&nbsp; attr;<br/>
<br/>

&nbsp;&nbsp;Datum() : attr(0) { }<br/>
&nbsp;&nbsp;Datum(Datum& d) {copy(d);}<br/>
&nbsp;~Datum() { }<br/>
<br/>
&nbsp;&nbsp;Datum& operator=  (Datum& d) {copy(d); return *this;}<br/>
<br/>
private:<br/>
&nbsp;&nbsp;void copy(Datum& d) {name = d.name; attr = d.attr;}<br/>
&nbsp;&nbsp;};<br/>
</blockquote>

<h3>A Full Example of Datum consistent with Expandable</h3>
<blockquote>

class Datum {<br/><br/>

String name;<br/>
int&nbsp;&nbsp;&nbsp;&nbsp;attr;<br/><br/>

public:<br/><br/>

&nbsp;&nbsp;Datum()        { }                                       // Copy constructor: Datum a = b;<br/>
&nbsp;&nbsp;Datum(Datum& d) {copy(d);}<br/>
&nbsp;~Datum()        { }<br/><br/>

&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;add(String& stg, int a);                               // Parse the data into the record}<br/>
<br/>

&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;display();<br/><br/>

&nbsp;&nbsp;Datum&   &nbsp;operator=&nbsp;&nbsp;(Datum& d) {copy(d); return *this;}   // Copy operator: a = b;<br/>
<br/>

&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;operator>=&nbsp;(Datum& d) {return s >= d.s;}&nbsp;&nbsp;&nbsp;// For data = datum (Insertion Sort)<br/>
&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;operator<=&nbsp;(Datum& d) {return s <= d.s;}&nbsp;&nbsp;&nbsp;// For qsort<br/>
&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;operator>&nbsp;&nbsp;(Datum& d) {return s >&nbsp;&nbsp;d.s;}&nbsp;&nbsp;&nbsp;// For qsort<br/>
&nbsp;&nbsp;// The rest of the conditionals<br/>
&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;operator==&nbsp;(Datum& d) {return s == d.s;}<br/>
&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;operator!=&nbsp;(Datum& d) {return s != d.s;}<br/>
&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;operator<&nbsp;&nbsp;(Datum& d) {return s <  &nbsp;d.s;}<br/>
<br/>
&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;operator==&nbsp;(Key key)&nbsp;&nbsp;{return s == key;}&nbsp;&nbsp;&nbsp;// For Binary and Linear Search<br/>
&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;operator&lt;&nbsp;&nbsp;(Key key)&nbsp;&nbsp;{return s &lt;&nbsp; key;}&nbsp;&nbsp;&nbsp;// For Binary Search<br/>
&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;operator&gt;&nbsp;&nbsp;(Key key)&nbsp;&nbsp;{return s &gt;&nbsp; key;}&nbsp;&nbsp;&nbsp;// For Binary Search<br/><br/>

private:<br/>
<br/>
&nbsp;&nbsp;void copy(Datum& d) {name = d.name; attr = d.attr;}<br/>
&nbsp;&nbsp;};<br/>
</blockquote>

<p>
The binary and linear search operators have an interesting property.  The Key type may be reference to the 
actual key type.  The Key Type may also be any type for which boolean operators are available for 
the Datum class.  In this case, String has booleans where the second operator is an old fashion 
c string or in the case of UniCode a TCchar* type.
</p>

</section>
  <!-- InstanceEndEditable --></article>
  <!-- end .content -->

  <footer>
    <hr />
    <div>
      <a href="../index.htm">Home</a>&nbsp;&nbsp;
      <a href="../Modules/index.htm">Modules</a>&nbsp;&nbsp;
      <a href="../Pictures.htm">Pictures</a>
      <a href="index.htm">Prog Guide</a>
    </div>
    <div>eMail: romeo romeo victor tango alpha tango sam whiskey delta echo dot charlie oscar mike</a></div>
    <div>Last modified:&nbsp; <!-- #BeginDate format:Am2 -->7/30/24<!-- #EndDate --></div>
    <div align="center">Copyright SD&E.&nbsp; All rights reserved.</div>
  </footer>
  <!-- end .container -->
</div></body>
<!-- InstanceEnd --></html>
